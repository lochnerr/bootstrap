#!/bin/sh

# /usr/local/bin/bootstrap-startup

set -e

# This script is designed to allow automated startup of generic linux images.

# In a bare-metal environment, the image would typically be a custom live (run-from-ram)
# image booted from a usb stick or DVD or even via pxe.

# In a VM environment, the image would be a cloud-init image booted from a virtual disk volume
# with a corresponding cloud-init cidata volume or a live alpine bootstrap iso.

# The bootstrap process does the following on startup:

# Searches for a bootstrap device.
# Mounts the bootstrap device on /mnt.
# Copies /mnt/bootstrap files to /tmp/bootstrap.
# Unmounts /mnt.
# Mount persistent /srv directory, unless not required.
# Add /srv/local/bin to path, if it exists.
# Mount persistent root.
# Mount persistent home.
# Copy ssh identifiers.
# Setup persistent apk cache for alpine.
# TODO Local admin password???
# Stop the libvirtd, if it exists on the boot device.
# Bind xen and libvirt directories (if needed).
# Sets up networking (based on the bootstrap files).
# Restarts networking, if required.
# Start the libvirtd, if it exists on the boot device.
# If there is a /tmp/bootstrap/startup or /tmp/bootstrap/start script from the bootstrap volume, execute it.

# Note. If no bootstrap device is found, the process does the following instead:

# Start the libvirtd, if it exists on the boot device.
# Execute the startup script.

# On shutdown:

# Remounts the bootstrap device on /mnt.
# Copies network changes back to the bootstrap device for persistence.
# Unmounts /mnt.
# If there is a /tmp/bootstrap/shutdown or /tmp/bootstrap/stop script from the bootstrap volume, execute it.

# The bootstrap environment must be identified: bare metal or virtual. This
# determines the bootstrap search order.

# If running in a dom0, it is bare metal.
# If running in a domU, it is virtual.
# If /dev/vdX devices exist, it is virtual (kvm).
# Otherwise, assume bare metal.

# The search order for virtual is:
# xen: /dev/xvdX devices.
# kvm: /dev/vdX devices.

# The search order for bare metal is:
# 1) /dev/vmh01/btrfs_a (backward compatibility).
# 2) lvm2 partitions containing 'bootstrap' in their name.
# 3) /dev/sdX devices.
# 4) all other lvm2 partitions.

# A match is found when the device is mounted on /mnt and
# there is a /mnt/bootstrap directory.

# The log directory
LOG="/tmp/bootstrap.log"
LOG="${LOG:-/dev/stdout}"

[ "$1" = "test" ] && test="true"

log() {
  echo "$(date +%H:%M:%S) $1" >>$LOG
  logger -t bootstrap "$1" || :
  ####echo "$1" | tee -a $LOG
}

try_device() {
  [ -z "$1" ] && return
  local rc="1"
  local blkid
  blkid="$(blkid -s TYPE $1 || :)"
  local fs_type
  fs_type=$(echo $blkid | cut -d '"' -f2)
  if [ -n "$fs_type" ]; then
      if echo 'btrfs ext4 vfat xfs ext3 ext2' | grep "$fs_type" >/dev/null 2>&1 ; then
          log "Trying device: $1 ($fs_type)"
          if mount -v -t $fs_type $1 /mnt >/dev/null; then
            if [ -d /mnt/bootstrap ]; then
              cp -a /mnt/bootstrap /tmp
              # Create mount script for use in shutdown (to persist network changes)."
              echo "#!/bin/sh" >/tmp/mount-bootstrap
              echo "mnt=\${1:-/mnt}" >>/tmp/mount-bootstrap
              echo "umount \$mnt 2>/dev/null || :" >>/tmp/mount-bootstrap
              echo "mount -v -t $fs_type $1 \$mnt" >>/tmp/mount-bootstrap
              chmod +x /tmp/mount-bootstrap
              # Indicate success.
              log "Found bootstrap directory on device."
              rc="0"
            else
              log "No bootstrap directory on device."
            fi
            umount /mnt || :
          else
            log "Device mount failed."
          fi
      else
        log "Not trying device: $1 ($fs_type)"
      fi
  fi
  return $rc
}

try_device_node() {
  log "Trying devices in /dev/${1}*."
  for dev in $(ls /dev/${1}* 2>/dev/null); do
    if try_device $dev ; then
      echo "$dev"
      return 0
    fi
  done
  return 0
}

wait_for_lvs() {
  # Wait for the volumes to become active.  This can take a while if there are many volumes.
  while (( "$#" )); do
    local vg=$1
    local lv=$2
    local i
    shift 3
    for i in {1..30} ; do
      local lv_attr="$(lvs $vg/$lv --noheadings -o lv_attr)"
      if [ "${lv_attr:6:1}" = "a" ]; then
        log "Volume $vg/$lv is active."
        break
      elif [ "${lv_attr:6:1}" = "-" ] || [ "${lv_attr:6:1}" = "i" ]; then
        log "Waiting for logical volume $vg/$lv to become active:${lv_attr}."
        sleep 3s
      else
        log "Warning: volume $vg/$lv has unexpected attributes:${lv_attr}."
        break
      fi
    done
    [ "${lv_attr:6:1}" != "a" ] && log "Warning: volume $vg/$lv did not become active."
  done
  return 0
}

process_lv() {
  wait_for_lvs $@
  # Now, hopefully the volumes are all online.  
  # Try them one at a time.
  while (( "$#" )); do
    local vg=$1
    local lv=$2
    shift 3
    if try_device "/dev/$vg/$lv" ; then
      echo "/dev/$vg/$lv"
      return 0
    fi
  done
  return 0
}

try_lvs() {
  msg="Trying logical volumes named '$1'."
  local inverse
  if [ -n "$2" ]; then
    msg="Trying volumes not named '$1'."
    inverse="-v"
  fi
  log "$msg"
  if [ ! -z "$(command -v lvs 2> /dev/null)" ]; then
    local scan="$(lvs --noheadings -o vg_name,lv_name,lv_attr | grep $inverse $1 || :)"
    local rv=""
    if [ -n "$scan" ]; then
      rv=$(process_lv $scan)
    else
      log "No volumes found."
    fi
    echo $rv
  fi
}

do_bare_metal() {
  local rv
  # Alpine needs vgscan.
  if [ -x /sbin/setup-alpine ]; then
    log "Doing vgscan."
    vgscan >/dev/null 2>&1 || :
  fi
  log "Bare Metal $1"
  # Try logical volume names containing 'bootstrap'.
  [ -z "$rv" ] && rv="$(try_lvs bootstrap)"
  # Try disk partitions.
  [ -z "$rv" ] && rv="$(try_device_node sd)"
  # Try all other logical volumes.
  [ -z "$rv" ] && rv="$(try_lvs bootstrap inverse)"
  [ -z "$rv" ] && log "Warning: No bootstrap device found."
  echo "$rv"
}

find_and_copy_bootstrap_files() {
  local rv
  if [ -f /proc/xen/capabilities ]; then
    if [ ! -z "$(cat /proc/xen/capabilities)" ]; then
      rv="$(do_bare_metal dom0)"
    else
      log "VM domU xvd"
      rv="$(try_device_node xvd)"
    fi
  elif ls /dev/xvd* 2>/dev/null >/dev/null; then
    log "VM xen xvd"
    rv="$(try_device_node xvd)"
  elif ls /dev/vd* 2>/dev/null >/dev/null; then
    log "VM kvm vd"
    rv="$(try_device_node vd)"
  else
    rv="$(do_bare_metal kernel)"
  fi
  echo "$rv"
}

# For testing, a custom bootstrap-startup file can be placed in /srv/bootstrap/bootstrap-startup.
# Once the bootstrap files have been copied, the standard process will "exec" the custom script
# which will continue with the files previously copied.
MODE="standard"
[ "${0:0:4}" = "/tmp" ] && MODE="custom"

if [ "$MODE" = "standard"  ]; then

  # Delete existing /tmp/bootstrap files prior to searching for them on external volumes.
  rm -rf /tmp/bootstrap
  rm -f /tmp/mount-bootstrap
  rm -f /tmp/bootstrap.log

  # If alpine, load btrfs module.
  if [ -x /sbin/setup-alpine ]; then
    modprobe btrfs
  fi

  # Find and copy bootstrap files.
  res="$(find_and_copy_bootstrap_files)"
  if [ ! -z "$res" ]; then
    log "Bootstrap files successfully copied."
    # Exec the custom script, if there is one.
    if [ -x /tmp/bootstrap/bootstrap-startup ]; then
      log "Chaining to custom bootstrap startup script."
      exec /tmp/bootstrap/bootstrap-startup
      log "This should never be reached."
    fi
  else
    log "Bootstrap files not copied."
  fi
  log "Continuing with standard bootstrap process."
else
  log "Continuing with custom bootstrap process."
fi

# Source bootstrap options, if available.
[ -e /tmp/bootstrap/bootstrap.conf ] && . /tmp/bootstrap/bootstrap.conf

if [ -n "$HOST" ]; then
  if [ -x /sbin/setup-alpine ]; then
    # Alpine doesn't like fqdn.
    log "Setting hostname to ${HOST}."
    /sbin/setup-hostname "$(echo $HOST | cut -d '.' -f 1)"
    /etc/init.d/hostname --quiet restart
  else
    FQDN=$HOST
    [ -n "$DOMAIN" ] && FQDN="${FQDN}.$DOMAIN"
    log "Setting hostname to ${FQDN}."
    hostname $FQDN
  fi
fi

[ ! -z "$test" ] && exit 0

# Generic service control function.
service_control() {

  if [ ! -z "$(command -v systemctl 2> /dev/null)" ]; then
    log "Service $2 $1 (systemd)"
    systemctl $1 $2 || :
  else
    log "Service $2 $1 (init)"
    /etc/init.d/$2 $1 || :
    /etc/init.d/$2 status || :
  fi
}

# Mount persistent /srv directory, unless disabled.
if [ -z "$DISABLE_SRV_MOUNT" ]; then
  if [ -x /tmp/mount-bootstrap ]; then
    log "Mounting persistent /srv directory."
    /tmp/mount-bootstrap /srv
  fi
fi

# Add /srv/local/bin to path, if it exists.
if [ -d /srv/local/bin ]; then
  PATH=${PATH}:/srv/local/bin
fi

create_persisent_dir() {

  # If the source directory exists.
  if [ -d /$1 ]; then
    # If the persistent does not.
    if [ ! -d /srv/$1 ]; then
      log "Creating persistent directory: /srv/${1}."
      mkdir -p /srv/${1}
      cp -a /$1 /srv/${1}/../
    fi
  fi
}

# Create the persistent xen & libvirt directories, if necessary.
create_persisent_dir var/lib/xen
create_persisent_dir var/log/xen
create_persisent_dir etc/libvirt
create_persisent_dir var/lib/libvirt
create_persisent_dir var/log/libvirt
create_persisent_dir root
create_persisent_dir home

# If this is the first run, persist the ssh host keys.
if [ -d /srv/bootstrap ] && [ ! -d /srv/bootstrap/ssh ]; then
  log "Creating persistent ssh host keys."
  mkdir -p /srv/bootstrap/ssh
  cp /etc/ssh/ssh_host* /srv/bootstrap/ssh
fi

# Mount persistent root.
if [ -d /srv/root ]; then 
  log "Mounting persistent root."
  umount /root 2>/dev/null || :
  mount --bind /srv/root      /root
fi

# Mount persistent home.
if [ -d /srv/home ]; then 
  log "Mounting persistent home."
  umount /home 2>/dev/null || :
  mount --bind /srv/home      /home
fi

# Copy ssh identifiers.
if [ -d /tmp/bootstrap/ssh ]; then 
  log "Copying ssh keys."
  mkdir -p /etc/ssh
  cp -p /tmp/bootstrap/ssh/ssh_host*    /etc/ssh/
fi

# Setup persistent apk cache for alpine.
if [ -x /sbin/setup-alpine ]; then
  if [ -d /srv/apkcache ]; then
    log "Setting up persistent apk cache for Alpine!"
    setup-apkcache /srv/apkcache
  fi
  #?? setup-apkrepos -1
fi

# TODO Local admin password???

# Stop the libvirtd daemon, if it's running and there is a bootstrap volume.
if [ -n "$(ps aux | grep -i [l]ibvirtd)" ] && [ -x /tmp/mount-bootstrap ]; then
  service_control stop libvirtd
fi

# Bind xen and libvirt directories (if needed).
if [ -f /proc/xen/capabilities ]; then
  if [ ! -z "$(cat /proc/xen/capabilities)" ]; then
    log "Mounting persistent xen/libvirt volumes."
    [ -d /srv/var/lib/xen ]     && mount --bind /srv/var/lib/xen      /var/lib/xen
    [ -d /srv/var/log/xen ]     && mount --bind /srv/var/log/xen      /var/log/xen
    [ -d /srv/etc/libvirt ]     && mount --bind /srv/etc/libvirt      /etc/libvirt
    [ -d /srv/var/lib/libvirt ] && mount --bind /srv/var/lib/libvirt  /var/lib/libvirt
    [ -d /srv/var/log/libvirt ] && mount --bind /srv/var/log/libvirt  /var/log/libvirt
  else
    # Nothing to do.  This is a xen DomU.
    true
  fi
else
  # No proc/xen/capabilities so must be a kvm VM or a kvm bare-metal host.
  # TODO Is this right?
  if [ -d /srv/etc/libvirt ]; then
    log "Mounting persistent libvirt volumes."
    [ -d /srv/etc/libvirt ]         && mount --bind /srv/etc/libvirt          /etc/libvirt
    [ -d /srv/var/lib/libvirt-kvm ] && mount --bind /srv/var/lib/libvirt-kvm  /var/lib/libvirt
    [ -d /srv/var/log/libvirt-kvm ] && mount --bind /srv/var/log/libvirt-kvm  /var/log/libvirt
  fi
fi

[ -f /tmp/bootstrap/skip-network ] && NO_NETWORKING="true"

# Copy network scripts.
if [ ! -z "$NO_NETWORKING" ]; then
  log "Skipping network configuration."
else
  if [ -d /tmp/bootstrap/network-scripts ]; then
    log "Copying network scripts."
    NETWORK_RECONFIGURED="true"
    # Remove all but the loopback device scripts
    [ -f /etc/sysconfig/network-scripts/ifcfg-lo ] && mv /etc/sysconfig/network-scripts/ifcfg-lo /etc/sysconfig/network-scripts/ifcfx-lo
    rm -f /etc/sysconfig/network-scripts/ifcfg-*
    [ -f /etc/sysconfig/network-scripts/ifcfx-lo ] && mv /etc/sysconfig/network-scripts/ifcfx-lo /etc/sysconfig/network-scripts/ifcfg-lo
    cp -a /tmp/bootstrap/network-scripts/* /etc/sysconfig/network-scripts
  fi
  if [ -f /tmp/bootstrap/network/interfaces ]; then
    log "Copying network interfaces."
    NETWORK_RECONFIGURED="true"
    cp -a /tmp/bootstrap/network/interfaces /etc/network/interfaces
  fi
fi

wait_for_internet_poll() {
  # Wait up to 45 seconds for internet connectivity.
  for try in {0..15} ; do
    [ "$try" != "0" ] && sleep 2s
    log "Checking for internet connectivity."
    ping -q -c 1 -W 1 8.8.8.8 >/dev/null && break
  done
}

wait_for_internet() {

  if wait_for_internet_poll ; then
    log "Internet is up!"
  else
    log "Internet is not up!"
  fi
}

# Start/restart networking.
if [ -n "$NO_NETWORKING" ]; then
  log "Skipping network restart."
elif [ -n "$NETWORK_RECONFIGURED" ]; then
  # Only restart network if it has been reconfigured.
  if [ -x /sbin/setup-alpine ]; then
    # Alpine
    log "Restarting network (Alpine/Other)."
    /etc/init.d/networking restart
  elif [ -d /etc/yum.repos.d ]; then
    # centos/redhat/fedora
    log "Restarting NetworkManager (Redhat/Fedora/Centos)"
    systemctl restart NetworkManager
  elif [ ! -z "$(command -v apt-get 2> /dev/null)" ]; then
    # debian/ubuntu
    log "Starting networking (Debian/Ubuntu)"
    systemctl restart NetworkManager
  else
    log "Warning: Don't know how to restart networking."
  fi
fi

if [ -z "$NO_NETWORKING" ]; then
  wait_for_internet
fi

# Start the libvirtd, if it exists on the boot device and is not running.
if [ ! -z "$(command -v libvirtd 2> /dev/null)" ] && [ -z "$(ps aux | grep -i [l]ibvirtd)" ]; then
  service_control start libvirtd
fi

# Execute the startup script.
start_script="/tmp/bootstrap/start"
[ ! -x $start_script ] && start_script="/tmp/bootstrap/startup"
if [ -x $start_script ]; then
  log "Executing startup script."
  $start_script >>$LOG
  log "startup script finished."
else
  log "Not using startup script."
fi

log "Bootstrap startup completed!"

